//go:build !ignore_autogenerated

// Code generated by controller-gen. DO NOT EDIT.

package v1alpha1

import (
	runtime "k8s.io/apimachinery/pkg/runtime"
	corev1 "k8s.io/api/core/v1"
)

// DeepCopyInto copies all properties into another SkillExecution.
func (in *SkillExecution) DeepCopyInto(out *SkillExecution) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy returns a deep copy of SkillExecution.
func (in *SkillExecution) DeepCopy() *SkillExecution {
	if in == nil {
		return nil
	}
	out := new(SkillExecution)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject returns a deep copy as runtime.Object.
func (in *SkillExecution) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto copies all properties into another SkillExecutionList.
func (in *SkillExecutionList) DeepCopyInto(out *SkillExecutionList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]SkillExecution, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy returns a deep copy of SkillExecutionList.
func (in *SkillExecutionList) DeepCopy() *SkillExecutionList {
	if in == nil {
		return nil
	}
	out := new(SkillExecutionList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject returns a deep copy as runtime.Object.
func (in *SkillExecutionList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto copies all properties into another SkillExecutionSpec.
func (in *SkillExecutionSpec) DeepCopyInto(out *SkillExecutionSpec) {
	*out = *in
	out.Skill = in.Skill
	in.Input.DeepCopyInto(&out.Input)
	in.Runner.DeepCopyInto(&out.Runner)
	if in.Secrets != nil {
		in, out := &in.Secrets, &out.Secrets
		*out = new(SecretsSpec)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy returns a deep copy of SkillExecutionSpec.
func (in *SkillExecutionSpec) DeepCopy() *SkillExecutionSpec {
	if in == nil {
		return nil
	}
	out := new(SkillExecutionSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto copies all properties into another ExecutionInput.
func (in *ExecutionInput) DeepCopyInto(out *ExecutionInput) {
	*out = *in
	if in.Parameters != nil {
		in, out := &in.Parameters, &out.Parameters
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy returns a deep copy of ExecutionInput.
func (in *ExecutionInput) DeepCopy() *ExecutionInput {
	if in == nil {
		return nil
	}
	out := new(ExecutionInput)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto copies all properties into another SkillRef.
func (in *SkillRef) DeepCopyInto(out *SkillRef) {
	*out = *in
}

// DeepCopy returns a deep copy of SkillRef.
func (in *SkillRef) DeepCopy() *SkillRef {
	if in == nil {
		return nil
	}
	out := new(SkillRef)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto copies all properties into another RunnerSpec.
func (in *RunnerSpec) DeepCopyInto(out *RunnerSpec) {
	*out = *in
	if in.RuntimeClassName != nil {
		in, out := &in.RuntimeClassName, &out.RuntimeClassName
		*out = new(string)
		**out = **in
	}
	in.Resources.DeepCopyInto(&out.Resources)
}

// DeepCopy returns a deep copy of RunnerSpec.
func (in *RunnerSpec) DeepCopy() *RunnerSpec {
	if in == nil {
		return nil
	}
	out := new(RunnerSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto copies all properties into another SecretsSpec.
func (in *SecretsSpec) DeepCopyInto(out *SecretsSpec) {
	*out = *in
	if in.EnvFrom != nil {
		in, out := &in.EnvFrom, &out.EnvFrom
		*out = make([]corev1.EnvFromSource, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy returns a deep copy of SecretsSpec.
func (in *SecretsSpec) DeepCopy() *SecretsSpec {
	if in == nil {
		return nil
	}
	out := new(SecretsSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto copies all properties into another SkillExecutionStatus.
func (in *SkillExecutionStatus) DeepCopyInto(out *SkillExecutionStatus) {
	*out = *in
	if in.StartTime != nil {
		in, out := &in.StartTime, &out.StartTime
		*out = (*in).DeepCopy()
	}
	if in.CompletionTime != nil {
		in, out := &in.CompletionTime, &out.CompletionTime
		*out = (*in).DeepCopy()
	}
}

// DeepCopy returns a deep copy of SkillExecutionStatus.
func (in *SkillExecutionStatus) DeepCopy() *SkillExecutionStatus {
	if in == nil {
		return nil
	}
	out := new(SkillExecutionStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto copies all properties into another ExecutionPolicy.
func (in *ExecutionPolicy) DeepCopyInto(out *ExecutionPolicy) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
}

// DeepCopy returns a deep copy of ExecutionPolicy.
func (in *ExecutionPolicy) DeepCopy() *ExecutionPolicy {
	if in == nil {
		return nil
	}
	out := new(ExecutionPolicy)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject returns a deep copy as runtime.Object.
func (in *ExecutionPolicy) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto copies all properties into another ExecutionPolicyList.
func (in *ExecutionPolicyList) DeepCopyInto(out *ExecutionPolicyList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]ExecutionPolicy, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy returns a deep copy of ExecutionPolicyList.
func (in *ExecutionPolicyList) DeepCopy() *ExecutionPolicyList {
	if in == nil {
		return nil
	}
	out := new(ExecutionPolicyList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject returns a deep copy as runtime.Object.
func (in *ExecutionPolicyList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto copies all properties into another ExecutionPolicySpec.
func (in *ExecutionPolicySpec) DeepCopyInto(out *ExecutionPolicySpec) {
	*out = *in
	if in.RuntimeClassName != nil {
		in, out := &in.RuntimeClassName, &out.RuntimeClassName
		*out = new(string)
		**out = **in
	}
	in.ResourceDefaults.DeepCopyInto(&out.ResourceDefaults)
	if in.NetworkPolicy != nil {
		in, out := &in.NetworkPolicy, &out.NetworkPolicy
		*out = new(NetworkPolicySpec)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy returns a deep copy of ExecutionPolicySpec.
func (in *ExecutionPolicySpec) DeepCopy() *ExecutionPolicySpec {
	if in == nil {
		return nil
	}
	out := new(ExecutionPolicySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto copies all properties into another NetworkPolicySpec.
func (in *NetworkPolicySpec) DeepCopyInto(out *NetworkPolicySpec) {
	*out = *in
	if in.AllowEgress != nil {
		in, out := &in.AllowEgress, &out.AllowEgress
		*out = make([]EgressRule, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy returns a deep copy of NetworkPolicySpec.
func (in *NetworkPolicySpec) DeepCopy() *NetworkPolicySpec {
	if in == nil {
		return nil
	}
	out := new(NetworkPolicySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto copies all properties into another EgressRule.
func (in *EgressRule) DeepCopyInto(out *EgressRule) {
	*out = *in
	if in.To != nil {
		in, out := &in.To, &out.To
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.Ports != nil {
		in, out := &in.Ports, &out.Ports
		*out = make([]int, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy returns a deep copy of EgressRule.
func (in *EgressRule) DeepCopy() *EgressRule {
	if in == nil {
		return nil
	}
	out := new(EgressRule)
	in.DeepCopyInto(out)
	return out
}
